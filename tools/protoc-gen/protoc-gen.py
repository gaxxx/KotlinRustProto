#!/usr/bin/env python3

# Generates BackendService.java from backend.proto
# This is the serialization mechanism/calling conventions for protobufs between rslib and rsdroid

import sys

from google.protobuf.compiler import plugin_pb2 as plugin

base_dir = "com/linkedin/android/rpc/"


class Service:
    def __init__(self, service, proto_file):
        self.service = service
        self.proto_file = proto_file
        self.pkg = proto_file.options.java_package
        self.rpcs = []


class RPC:
    def __init__(self, method, command_num, pkg):
        self.method = method
        self.command_num = command_num
        self.pkg = pkg

    def is_valid(self):
        return self.get_input() and self.get_output()

    def get_input(self):
        return self.pkg + self.method.input_type

    def get_output(self):
        return self.pkg + self.method.output_type
        
    def __repr__(self):
        output = self.get_output()
        has_resp = "false"
        if output.endswith(".Resp"):
            has_resp = "true"
            output = output.replace(".Resp", ".Empty")

        # These previously were very different - validation changed this.
        # Might want to merge these branches now they're so similar.
        return '''public void {name}({input} args, RustCore.Callback<{output}> cb) {{
    boolean hasResp = {has_resp};
    byte[] resp = RESP_PROTO.clone();
    byte[] result = executeCommand({number}, args.toByteArray(), resp);
    if (cb == null) {{
        return;
    }}
    if (result.length == 0) {{
        {pkg}.Proto.Resp r = getResp(resp);
        if (r != null && r.getRet() != 0) {{
            cb.onErr(r.getRet() , r.getMsg());
            return;
        }}
    }}
    
    if (hasResp) {{
        {pkg}.Proto.Resp r = getResp(resp);
        if (r != null && r.getRet() != 0) {{
            cb.onErr(r.getRet() , r.getMsg());
            return;
        }}
        cb.onSuccess({output}.getDefaultInstance());
    }} else {{
        {output} message = null;
        try {{
            message = {output}.parseFrom(result);
        }} catch (InvalidProtocolBufferException e) {{
            e.printStackTrace();
        }}
        cb.onSuccess(message);
        }}
    }}'''.format(input=self.get_input(), output=output,
                 has_resp = has_resp, name = self.method_name(), number = self.command_num,
                 pkg = self.pkg
                   )

    def method_name(self):
        return self.method.name[0].lower() + self.method.name[1:]


def traverse(proto_file):
    classes = []

    for f in proto_file.service:
        service = Service(f, proto_file)
        for i, m in enumerate(f.method):
            cls = RPC(m, i + 1, proto_file.options.java_package)
            service.rpcs.append(cls)
        classes.append(service)

    return classes

def logRepr(s):
    sys.stderr.write("\n".join(dir(s)))

def log(s):
    sys.stderr.write(str(s) + "\n")

def gen_backend_methods(service):
    proto_file = service.proto_file
    class_name = service.service.name
    def gen_name_decl(method):
        return "{}.{}".format(class_name + "Methods", method.upper())
    name_decl = ",\n".join([gen_name_decl(rpc.method_name()) for rpc in service.rpcs])

    def gen_name_def(rpc):
        return "    int {} = {};".format(rpc.method_name().upper(), rpc.command_num)
    name_def = "\n".join([gen_name_def(rpc) for rpc in service.rpcs])

    def gen_name_sig(rpc):
        return "{}:{}:{}".format(rpc.get_input().split('.')[-1], rpc.method_name(), rpc.get_output().split('.')[-1])

    name_sig = "|".join(gen_name_sig(rpc) for rpc in service.rpcs);

    content = '''/*This class was autogenerated from {proto_name} by {file}
Please Rebuild project to regenerate.
*/
package com.linkedin.android.rpc;

import java.lang.annotation.Retention;
import androidx.annotation.IntDef;
import java.lang.annotation.RetentionPolicy;
import androidx.annotation.Nullable;
@IntDef ({{
{name_decl}
}})
public @interface {intf_name}Methods {{
{name_def}

static final String signature = "{name_sig}";
}}
'''.format(proto_name=proto_file.name, file=__file__, intf_name=class_name,name_decl=name_decl, name_def=name_def, name_sig=name_sig);
    file = response.file.add()
    file.name = base_dir + class_name + "Methods.java"
    file.content = content

def generate_code(request, response):
    for proto_file in request.proto_file:
        services = traverse(proto_file)
        if not services:
            continue

        for service in services:
            generate_service(service)

def generate_service(service):
    global class_name
    global proto_name
    class_name = service.service.name
    proto_name = service.proto_file.name.replace(".proto", "")

    file_contents = ['''
/* 
This class was autogenerated from {} by {}
Please Rebuild project to regenerate.
 */
package com.linkedin.android.rpc;
import androidx.annotation.Nullable;
import androidx.annotation.NonNull;
import com.linkedin.android.rsdroid.RustCore;
import com.google.protobuf.InvalidProtocolBufferException;
import kotlin.text.StringsKt;

public abstract class {cls} {{ 
    static final byte[] RESP_PROTO = {pkg}.Proto.Resp.newBuilder()
            .setRet(0)
            .setMsg(StringsKt.repeat(" ", 128)).build().toByteArray();
            
    protected {pkg}.Proto.Resp getResp(byte[] resp) {{
        try {{
            return {pkg}.Proto.Resp.parseFrom(resp);
        }} catch (InvalidProtocolBufferException e) {{
            return null;
        }}
    }}
    protected abstract byte[] executeCommand(final int command, byte[] args, byte[] resp);
'''.format(service.proto_file.name, __file__, cls=class_name, pkg = service.pkg)]

    for rpc in service.rpcs:
        file_contents.append("\n\n" + str(rpc))

    file_contents.append("\n}")

    # Fill response
    f = response.file.add()
    f.name = base_dir + class_name + ".java"
    f.content = "\n".join(file_contents)

    # generate BackendMethods

    gen_backend_methods(service)


if __name__ == '__main__':
    # Read request message from stdin
    data = sys.stdin.buffer.read()

    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.buffer.write(output)
