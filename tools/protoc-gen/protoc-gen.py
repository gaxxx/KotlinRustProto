#!/usr/bin/env python3

# Generates BackendService.java from backend.proto
# This is the serialization mechanism/calling conventions for protobufs between rslib and rsdroid

import sys

from google.protobuf.compiler import plugin_pb2 as plugin

base_dir = "com/linkedin/android/rpc/"

class Method:
    def __init__(self, method):
        self.method = method
        self.fields = method.field

def parse(str):
    return str.replace(".Proto.", class_name + ".")


class RPC:
    def __init__(self, service, command_num, methods):
        self.method = service
        self.command_num = command_num
        self.method_lookup = methods

    def is_valid(self):
        return self.get_input() and self.get_output()

    def get_input(self):
        return parse(self.method.input_type)

    def get_output(self):
        return parse(self.method.output_type)
        
    def as_interface(self):
        return "    void {name}({input} args, RustCore.Callback<{output}> cb);"\
            .format(name=self.method_name(), input = self.get_input(), output = self.get_output())


    def __repr__(self):
        output = self.get_output()
        has_resp = "false"
        if output == "Native.Resp":
            has_resp = "true"
            output = "Native.Empty"

        # These previously were very different - validation changed this.
        # Might want to merge these branches now they're so similar.
        return '''public void {name}({input} args, RustCore.Callback<{output}> cb) {{
    boolean hasResp = {has_resp};
    byte[] resp = RESP_PROTO.clone();
    byte[] result = executeCommand({number}, args.toByteArray(), resp);
    if (cb == null) {{
        return;
    }}
    if (result.length == 0) {{
        Native.Resp r = getResp(resp);
        if (r != null && r.getRet() != 0) {{
            cb.onErr(r.getRet() , r.getMsg());
            return;
        }}
    }}
    
    if (hasResp) {{
        Native.Resp r = getResp(resp);
        if (r != null && r.getRet() != 0) {{
            cb.onErr(r.getRet() , r.getMsg());
            return;
        }}
    }}
    {output} message = null;
    try {{
        message = {output}.parseFrom(result);
    }} catch (InvalidProtocolBufferException e) {{
        e.printStackTrace();
    }}
    cb.onSuccess(message);
    }}'''.format(input=self.get_input(), output=output, has_resp = has_resp, name = self.method_name(), number = self.command_num,
                   )

    def method_name(self):
        return self.method.name[0].lower() + self.method.name[1:]


def traverse(proto_file):
    classes = []
    method_lookup = {item.method.name: item for item in set(methods)}

    for f in proto_file.service:
        for i, m in enumerate(f.method):
            cls = RPC(m, i + 1, method_lookup)
            if not cls.is_valid():
                raise ValueError(str(m))
            classes.append(cls)

    return classes

def logRepr(s):
    sys.stderr.write("\n".join(dir(s)))

def log(s):
    sys.stderr.write(str(s) + "\n")

def gen_backend_methods(proto_file, methods, class_name):
    def gen_name_decl(method):
        return "{}.{}".format(class_name, method.upper())
    name_decl = ",\n".join([gen_name_decl(rpc.method_name()) for rpc in methods])

    def gen_name_def(rpc):
        return "    int {} = {};".format(rpc.method_name().upper(), rpc.command_num)
    name_def = "\n".join([gen_name_def(rpc) for rpc in methods])

    content = '''/*This class was autogenerated from {proto_name} by {file}
Please Rebuild project to regenerate.
*/
package com.linkedin.android.rpc;

import java.lang.annotation.Retention;
import androidx.annotation.IntDef;
import java.lang.annotation.RetentionPolicy;
import androidx.annotation.Nullable;
@IntDef ({{
{name_decl}
}})
public @interface {intf_name} {{
{name_def}
}}
'''.format(proto_name=proto_file.name, file=__file__, intf_name=class_name,name_decl=name_decl, name_def=name_def);
    file = response.file.add()
    file.name = base_dir + class_name + ".java"
    file.content = content

def generate_code(request, response):
    global proto_name
    global class_name
    proto_name = ""
    class_name = ""
    for proto_file in request.proto_file:

        service_methods = traverse(proto_file)
        if not service_methods:
            continue

        proto_name = proto_file.name.replace(".proto", "")
        class_name = proto_name.capitalize()

        current_import = "import com.linkedin.android.proto.{};".format(class_name)
        file_contents = ['''
/* 
This class was autogenerated from {} by {}
Please Rebuild project to regenerate.
 */
package com.linkedin.android.rpc;
import androidx.annotation.Nullable;
import androidx.annotation.NonNull;
import com.linkedin.android.rsdroid.RustCore;
import com.google.protobuf.InvalidProtocolBufferException;
import com.linkedin.android.proto.Native;
import kotlin.text.StringsKt;

{currentImport}
public abstract class {cls}Service  {{ 
    static final byte[] RESP_PROTO = Native.Resp.newBuilder()
            .setRet(0)
            .setMsg(StringsKt.repeat(" ", 128)).build().toByteArray();
            
    protected Native.Resp getResp(byte[] resp) {{
        try {{
            return Native.Resp.parseFrom(resp);
        }} catch (InvalidProtocolBufferException e) {{
            return null;
        }}
    }}
    protected abstract byte[] executeCommand(final int command, byte[] args, byte[] resp);
'''.format(proto_file.name, __file__, cls=class_name, currentImport = current_import)]

        for method in service_methods:
            file_contents.append("\n\n" + str(method))
            
        file_contents.append("\n}")

        # Fill response
        f = response.file.add()
        f.name = base_dir + class_name + "Service.java"
        f.content = "\n".join(file_contents)
        
        # generate BackendMethods
        
        gen_backend_methods(proto_file, service_methods, class_name + "Methods")


if __name__ == '__main__':
    # Read request message from stdin
    data = sys.stdin.buffer.read()

    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.buffer.write(output)
